#!/usr/bin/env python

import itertools
from script.utilities.logger import logger
from script.profile import residue_type_dict, create_residue_interaction_profile
import argparse

from joblib import Parallel, delayed
from script.utilities.Bio import PDB as uPDB
from script.alignresenv import align_res_env
from script.resenv import resenv
from script import maxpmap

from script.utilities import util
import glob
VERSION = "0.1.0"


# TODO: which map should be used? nVH? others?


def gen_maxpmap(setting):
    basedirpath = setting["general"]["workdir"]
    JOB_NAME = setting["general"]["name"]

    logger.info("PMAP aggregation: mapPMAP")
    maxpmap.gen_max_pmap(
        glob.glob(f"{basedirpath}/system*/PMAP_{JOB_NAME}_nVH.dx"),
        f"{basedirpath}/maxPMAP_{JOB_NAME}_nVH.dx"
    )
    logger.info(f"Output file: {basedirpath}/maxPMAP_{JOB_NAME}_nVH.dx")


def extract_residue_environment(index, setting, verbose=False):
    basedirpath = setting["general"]["workdir"]
    sysdirpath = f'{basedirpath}/system{index}'
    PROBE_ID = setting["input"]["probe"]["cid"]
    JOB_NAME = setting["general"]["name"]

    # TODO: threshold should be configured
    resenv(grid=f"{basedirpath}/maxPMAP_{JOB_NAME}_nVH.dx",
           ipdb=[f"{sysdirpath}/{JOB_NAME}_woWAT_10ps.pdb"],
           resn=PROBE_ID,
           res_atomnames=[" CB "],
           opdb=f"{sysdirpath}/resenv_{JOB_NAME}.pdb",
           threshold=setting["probe_profile"]["threshold"],
           verbose=verbose
           )


def align_residue_environment(setting):
    basedirpath = setting["general"]["workdir"]
    PROBE_ID = setting["input"]["probe"]["cid"]
    JOB_NAME = setting["general"]["name"]

    # logger.debug("alignresenv start")

    pdbfiles = glob.glob(f"{basedirpath}/system*/resenv_{JOB_NAME}.pdb")
    ref_struct = uPDB.get_structure(pdbfiles[0])[0].copy()  # all structures are superimposed to this
    structures = [uPDB.get_structure(src) for src in pdbfiles]

    aligned = align_res_env(structures, ref_struct, PROBE_ID)
    with uPDB.PDBIOhelper(f"{basedirpath}/alignedresenv_{JOB_NAME}.pdb") as pdbio:
        for model in aligned:
            pdbio.save(model)

    logger.debug("alignresenv end")


def gen_residue_interaction_profile(setting):
    basedirpath = setting["general"]["workdir"]
    PROBE_ID = setting["input"]["probe"]["cid"]
    JOB_NAME = setting["general"]["name"]
    atom_names = [" CB "]

    for residue_type, residue_names in residue_type_dict.items():
        target_residue_atoms = [(res, atom) for res, atom in itertools.product(residue_names, atom_names)]
        try:
            struct = uPDB.get_structure(f"{basedirpath}/alignedresenv_{JOB_NAME}.pdb")
            g = create_residue_interaction_profile(struct, target_residue_atoms)
            g.export(f"{basedirpath}/{JOB_NAME}_{PROBE_ID}_mesh_{residue_type}.dx", type="short")
        except Exception as e:
            # glysine must be in here because it does not have CB atom
            logger.error(f"Error: {e} - skip this residue_type / residue_names pair")
            logger.error(f"residue_type: {residue_type}")
            logger.error(f"residue_names: {residue_names}")
            logger.error(f"atom_names: {atom_names}")


def probe_profile(setting, verbose=False):
    indices = util.expand_index(setting["general"]["iter_index"])

    gen_maxpmap(setting)
    # TODO n_jobs must be configured with arguments/configure file
    n_jobs = -1
    if not setting["general"]["multiprocessing"]:
        n_jobs = 1
    Parallel(n_jobs=n_jobs)(
        delayed(extract_residue_environment)(idx, setting, verbose)
        for idx in indices
    )
    align_residue_environment(setting)
    gen_residue_interaction_profile(setting)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Calculate residue interaction profile around probe")
    parser.add_argument("setting_yaml")
    parser.add_argument("-v,--verbose", dest="verbose", action="store_true")
    parser.add_argument("--debug", action="store_true")
    parser.add_argument("--version", action="version", version=VERSION)
    args = parser.parse_args()

    if args.debug:
        logger.setLevel("debug")
    elif args.verbose:
        logger.setLevel("info")
    # else: logger level is "warn"

    logger.info(f"read yaml: {args.setting_yaml}")
    setting = util.parse_yaml(args.setting_yaml)

    probe_profile(setting, args.verbose)
